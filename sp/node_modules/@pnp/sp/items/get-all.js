import { InjectHeaders } from "@pnp/queryable";
import { _Items, Items } from "./types.js";
_Items.prototype.getAll = async function (requestSize = 2000, acceptHeader = "application/json;odata=nometadata") {
    // this will be used for the actual query
    // and we set no metadata here to try and reduce traffic
    const items = Items(this, "").top(requestSize).using(InjectHeaders({
        "Accept": acceptHeader,
    }));
    // let's copy over the odata query params that can be applied
    // $top - allow setting the page size this way (override what we did above)
    // $select - allow picking the return fields (good behavior)
    // $filter - allow setting a filter, though this may fail for large lists
    // $expand - allow expanding fields for filter/select support
    this.query.forEach((v, k) => {
        if (/^\$select|filter|top|expand$/i.test(k)) {
            items.query.set(k, v);
        }
    });
    // this will eventually hold the items we return
    const itemsCollector = [];
    // action that will gather up our results recursively
    const gatherer = (last) => {
        // collect that set of results
        itemsCollector.push(...last.results);
        // if we have more, repeat - otherwise resolve with the collected items
        return last.hasNext ? last.getNext().then(gatherer) : itemsCollector;
    };
    return items.getPaged().then(gatherer);
};
//# sourceMappingURL=get-all.js.map