import { __decorate } from "tslib";
import { isArray } from "@pnp/core";
import { body } from "@pnp/queryable";
import { defaultPath } from "../decorators.js";
import { spDelete, spPatch, spPost } from "../operations.js";
import { _SPInstance, spInvokableFactory, _SPCollection } from "../spqueryable.js";
import { encodePath } from "../utils/encode-path-str.js";
/**
 * Describes a collection of Form objects
 *
 */
let _TermStore = class _TermStore extends _SPInstance {
    /**
     * Gets the term groups associated with this tenant
     */
    get groups() {
        return TermGroups(this);
    }
    /**
     * Gets the term sets associated with this tenant
     */
    get sets() {
        return TermSets(this);
    }
    /**
     * Allows you to locate terms within the termStore
     *
     * @param params Search parameters used to locate the terms, label is required
     * @returns Array of terms including set information for each term
     */
    async searchTerm(params) {
        const query = Reflect.ownKeys(params).reduce((c, prop) => {
            c.push(`${prop}='${encodePath(params[prop])}'`);
            return c;
        }, []).join(",");
        return TermStore(this, `searchTerm(${query})`).expand("set")();
    }
    /**
     * Update settings for TermStore
     *
     * @param props The set or properties to update
     * @returns The updated term store information
     */
    update(props) {
        return spPatch(this, body(props));
    }
};
_TermStore = __decorate([
    defaultPath("_api/v2.1/termstore")
], _TermStore);
export { _TermStore };
export const TermStore = spInvokableFactory(_TermStore);
let _TermGroups = class _TermGroups extends _SPCollection {
    /**
     * Gets a term group by id
     *
     * @param id Id of the term group to access
     */
    getById(id) {
        return TermGroup(this, id);
    }
    /**
     * Adds a new term group to this store
     * @param props The set of properties
     * @returns The information on the create group
     */
    add(props) {
        return spPost(this, body(props));
    }
};
_TermGroups = __decorate([
    defaultPath("groups")
], _TermGroups);
export { _TermGroups };
export const TermGroups = spInvokableFactory(_TermGroups);
export class _TermGroup extends _SPInstance {
    /**
     * Gets the term sets associated with this tenant
     */
    get sets() {
        return TermSets(this, "sets");
    }
    /**
     * Deletes this group
     *
     * @returns void
     */
    delete() {
        return spDelete(this);
    }
}
export const TermGroup = spInvokableFactory(_TermGroup);
let _TermSets = class _TermSets extends _SPCollection {
    /**
     * Gets a term group by id
     *
     * @param id Id of the term group to access
     */
    getById(id) {
        return TermSet(this, id);
    }
    /**
     * Adds a new term set to this collection
     * @param props The set of properties
     * @returns The information on the create group
     */
    add(props) {
        return spPost(this, body(props));
    }
};
_TermSets = __decorate([
    defaultPath("sets")
], _TermSets);
export { _TermSets };
export const TermSets = spInvokableFactory(_TermSets);
export class _TermSet extends _SPInstance {
    /**
     * Gets all the terms in this set
     */
    get terms() {
        return Terms(this);
    }
    get parentGroup() {
        return TermGroup(this, "parentGroup");
    }
    get children() {
        return Children(this);
    }
    get relations() {
        return Relations(this);
    }
    getTermById(id) {
        return Term(this, `terms/${id}`);
    }
    /**
     * Update settings for TermSet
     *
     * @param props The set or properties to update
     * @returns The updated term set information
     */
    update(props) {
        return spPatch(this, body(props));
    }
    /**
     * Deletes this group
     *
     * @returns void
     */
    delete() {
        return spDelete(this);
    }
    /**
     * Gets all the terms in this termset in an ordered tree using the appropriate sort ordering
     * ** This is an expensive operation and you should strongly consider caching the results **
     *
     * @param props Optional set of properties controlling how the tree is retrieved.
     */
    async getAllChildrenAsOrderedTree(props = {}) {
        const selects = ["*", "customSortOrder"];
        if (props.retrieveProperties) {
            selects.push("properties", "localProperties");
        }
        const setInfo = await this.select(...selects)();
        const tree = [];
        const childIds = [];
        const ensureOrder = (terms, sorts, setSorts) => {
            // handle no custom sort information present
            if (!isArray(sorts) && !isArray(setSorts)) {
                return terms;
            }
            let ordering = null;
            if (sorts === null && setSorts.length > 0) {
                ordering = [...setSorts];
            }
            else {
                const index = sorts.findIndex(v => v.setId === setInfo.id);
                if (index >= 0) {
                    ordering = [...sorts[index].order];
                }
            }
            if (ordering !== null) {
                const orderedChildren = [];
                ordering.forEach(o => {
                    const found = terms.find(ch => o === ch.id);
                    if (found) {
                        orderedChildren.push(found);
                    }
                });
                // we have a case where if a set is ordered and a term is added to that set
                // AND the ordering information hasn't been updated in the UI the new term will not have
                // any associated ordering information. See #1547 which reported this. So here we
                // append any terms remaining in "terms" not in "orderedChildren" to the end of "orderedChildren"
                orderedChildren.push(...terms.filter(info => ordering.indexOf(info.id) < 0));
                return orderedChildren;
            }
            return terms;
        };
        const visitor = async (source, parent) => {
            const children = await source();
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                childIds.push(child.id);
                const orderedTerm = {
                    children: [],
                    defaultLabel: child.labels.find(l => l.isDefault).name,
                    ...child,
                };
                if (child.childrenCount > 0) {
                    await visitor(this.getTermById(children[i].id).children.select(...selects), orderedTerm.children);
                    orderedTerm.children = ensureOrder(orderedTerm.children, child.customSortOrder);
                }
                parent.push(orderedTerm);
            }
        };
        // There is a series of issues where users expect that copied terms appear in the result of this method call. Copied terms are not "children" so we need
        // to get all the children + all the "/terms" and filter out the children. This is expensive but this method call is already indicated to be used with caching
        await visitor(this.children.select(...selects), tree);
        await visitor(async () => {
            const terms = await Terms(this).select(...selects)();
            return terms.filter((t) => childIds.indexOf(t.id) < 0);
        }, tree);
        return ensureOrder(tree, null, setInfo.customSortOrder);
    }
}
export const TermSet = spInvokableFactory(_TermSet);
let _Children = class _Children extends _SPCollection {
    /**
     * Adds a new term set to this collection
     * @param props The set of properties
     * @returns The information on the create group
     */
    add(props) {
        return spPost(this, body(props));
    }
};
_Children = __decorate([
    defaultPath("children")
], _Children);
export { _Children };
export const Children = spInvokableFactory(_Children);
let _Terms = class _Terms extends _SPCollection {
    /**
     * Gets a term group by id
     *
     * @param id Id of the term group to access
     */
    getById(id) {
        return Term(this, id);
    }
};
_Terms = __decorate([
    defaultPath("terms")
], _Terms);
export { _Terms };
export const Terms = spInvokableFactory(_Terms);
export class _Term extends _SPInstance {
    get children() {
        return Children(this);
    }
    get relations() {
        return Relations(this);
    }
    get set() {
        return TermSet(this, "set");
    }
    /**
     * Update settings for TermSet
     *
     * @param props The set or properties to update
     * @returns The updated term set information
     */
    update(props) {
        return spPatch(this, body(props));
    }
    /**
     * Deletes this group
     *
     * @returns void
     */
    delete() {
        return spDelete(this);
    }
}
export const Term = spInvokableFactory(_Term);
let _Relations = class _Relations extends _SPCollection {
    /**
     * Adds a new relation to this term
     * @param props The set of properties
     * @returns The information on the created relation
     */
    add(props) {
        return spPost(this, body(props));
    }
};
_Relations = __decorate([
    defaultPath("relations")
], _Relations);
export { _Relations };
export const Relations = spInvokableFactory(_Relations);
//# sourceMappingURL=types.js.map