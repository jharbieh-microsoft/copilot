import { __decorate } from "tslib";
import { _GraphQueryableCollection, graphInvokableFactory, _GraphQueryableInstance } from "../graphqueryable.js";
import { defaultPath, deleteable, updateable, getById } from "../decorators.js";
import { graphGet, graphPost } from "../operations.js";
import { body } from "@pnp/queryable";
import { JSONHeaderParse } from "@pnp/queryable";
/**
 * Represents a content type entity
 */
let _ContentType = class _ContentType extends _GraphQueryableInstance {
    /**
      * Check the publishing status of a contentType in a content type hub site.
      */
    isPublished() {
        return graphGet(ContentType(this, "isPublished"));
    }
    /**
     * Publishes a contentType present in the content type hub site.
     */
    publish() {
        return graphPost(ContentType(this, "publish"));
    }
    /**
     * Unpublish a contentType from a content type hub site.
     */
    unpublish() {
        return graphPost(ContentType(this, "unpublish"));
    }
    /**
     * Associate a published content type present in a content type hub with a list of hub sites.
     *
     * @param hubSiteUrls List of canonical URLs to the hub sites where the content type needs to be enforced.
     * @param propagateToExistingLists (optional) If true, content types will be enforced on existing lists in the hub sites;
     * otherwise, it'll be applied only to newly created lists.
     */
    associateWithHubSites(hubSiteUrls, propagateToExistingLists) {
        const postBody = {
            hubSiteUrls: hubSiteUrls,
            propagateToExistingLists: propagateToExistingLists || false,
        };
        return graphPost(ContentType(this, "associateWithHubSites"), body(postBody));
    }
    /**
     * Copy a file to a default content location in a content type. The file can then be added as a default file or template via a POST operation.
     *
     * @param sourceFile Metadata about the source file that needs to be copied to the default content location. Required.
     * @param destinationFileName Destination filename.
     */
    copyToDefaultContentLocation(sourceFile, destinationFileName) {
        const postBody = {
            sourceFile,
            destinationFileName,
        };
        return graphPost(ContentType(this, "copyToDefaultContentLocation"), body(postBody));
    }
};
_ContentType = __decorate([
    deleteable(),
    updateable()
], _ContentType);
export { _ContentType };
export const ContentType = graphInvokableFactory(_ContentType);
/**
 * Describes a collection of content type objects
 *
 */
let _ContentTypes = class _ContentTypes extends _GraphQueryableCollection {
    /**
     * Add or sync a copy of a published content type from the content type hub to a target site or a list.
     *
     * @param contentTypeId The ID of the content type in the content type hub that will be added to a target site or a list.
     */
    async addCopyFromContentTypeHub(contentTypeId) {
        const creator = ContentType(this, null).using(JSONHeaderParse());
        const data = await graphPost(creator, body({ contentTypeId }));
        const pendingLocation = data.headers.location || null;
        return {
            data: data.data,
            contentType: this.getById(data.id),
            pendingLocation,
        };
    }
    /**
     * Get a list of compatible content types from the content type hub that can be added to a target site or a list.
     *
     */
    async getCompatibleHubContentTypes() {
        return graphGet(ContentTypes(this, "getCompatibleHubContentTypes"));
    }
};
_ContentTypes = __decorate([
    defaultPath("contenttypes"),
    getById(ContentType)
], _ContentTypes);
export { _ContentTypes };
export const ContentTypes = graphInvokableFactory(_ContentTypes);
//# sourceMappingURL=types.js.map