import { hOP, objectDefinedNotNull, stringIsNullOrEmpty } from "@pnp/core";
import { errorCheck, parseODataJSON } from "@pnp/queryable";
import { GraphQueryableCollection } from "../graphqueryable.js";
import { ConsistencyLevel } from "./consistency-level.js";
/**
 * Configures a collection query to returned paged results
 *
 * @param col Collection forming the basis of the paged collection, this param is NOT modified
 * @returns A duplicate collection which will return paged results
 */
export function AsPaged(col, supportsCount = false) {
    const q = GraphQueryableCollection(col).using(Paged(supportsCount), ConsistencyLevel());
    const queryParams = ["$search", "$top", "$select", "$expand", "$filter", "$orderby"];
    if (supportsCount) {
        // we might be constructing our query with a next url that will already contain $count so we need
        // to ensure we don't add it again, likewise if it is already in our query collection we don't add it again
        if (!q.query.has("$count") && !/\$count=true/i.test(q.toUrl())) {
            q.query.set("$count", "true");
        }
        queryParams.push("$count");
    }
    for (let i = 0; i < queryParams.length; i++) {
        const param = col.query.get(queryParams[i]);
        if (objectDefinedNotNull(param)) {
            q.query.set(queryParams[i], param);
        }
    }
    return q;
}
/**
 * Behavior that converts results to pages when used with a collection (exposed through the paged method of GraphCollection)
 *
 * @returns A TimelinePipe used to configure the queryable
 */
export function Paged(supportsCount = false) {
    return (instance) => {
        instance.on.parse.replace(errorCheck);
        instance.on.parse(async (url, response, result) => {
            const txt = await response.text();
            const json = txt.replace(/\s/ig, "").length > 0 ? JSON.parse(txt) : {};
            const nextLink = json["@odata.nextLink"];
            const count = supportsCount && hOP(json, "@odata.count") ? parseInt(json["@odata.count"], 10) : 0;
            const hasNext = !stringIsNullOrEmpty(nextLink);
            result = {
                count,
                hasNext,
                next: () => (hasNext ? AsPaged(GraphQueryableCollection([instance, nextLink]), supportsCount)() : null),
                value: parseODataJSON(json),
            };
            return [url, response, result];
        });
        return instance;
    };
}
//# sourceMappingURL=paged.js.map