import { __decorate } from "tslib";
import { GraphQueryableInstance, GraphQueryableCollection, _GraphQueryableInstance, _GraphQueryableCollection, graphInvokableFactory, GraphQueryable, } from "../graphqueryable.js";
import { combine } from "@pnp/core";
import { defaultPath, getById, deleteable, updateable } from "../decorators.js";
import { body, BlobParse, CacheNever, errorCheck, InjectHeaders } from "@pnp/queryable";
import { graphPatch, graphPost, graphPut } from "../operations.js";
import { driveItemUpload } from "./funcs.js";
import { AsPaged } from "../behaviors/paged.js";
/**
 * Describes a Drive instance
 *
 */
let _Drive = class _Drive extends _GraphQueryableInstance {
    /**
     * Method for retrieving the root folder of a drive.
     * @returns IRoot
     */
    get root() {
        return Root(this);
    }
    /**
     * Method for retrieving the related list resource, for use with SharePoint drives.
     * @returns IGraphQueryableInstance
     */
    get list() {
        return GraphQueryableInstance(this, "list");
    }
    /**
     * Method for retrieving recently accessed drive items by the user.
     * @returns IDriveItems
     */
    get recent() {
        return DriveItems(this, "recent");
    }
    /**
     * Method for retrieving drive items shared with the user.
     * @param options - ISharingWithMeOptions (Optional)
     * @returns IDriveItems
     */
    async sharedWithMe(options = null) {
        const q = DriveItems(this, "sharedWithMe");
        if ((options === null || options === void 0 ? void 0 : options.allowExternal) != null) {
            q.query.set("allowexternal", options === null || options === void 0 ? void 0 : options.allowExternal.toString());
        }
        return q();
    }
    /**
     * Method for retrieving a drive item by id.
     * @param id - string - the drive item id to retrieve
     * @returns IDriveItem
     */
    getItemById(id) {
        return DriveItem(this, combine("items", id));
    }
    /**
     * Method for retrieving drive items the user is following.
     * @returns IDriveItems
     */
    get following() {
        return DriveItems(this, "following");
    }
    /**
     * Get DriveItems by Path
     * @param path string, partial path to folder must not contain a leading or trailing "/" e.g. folderA/folderB/folderC
     * @returns IDriveItems
     */
    getItemsByPath(path) {
        return DriveItems(this, combine("root:/", `${path}:/children`));
    }
    /**
     * Get DriveItem by Path
     * @param path string, partial path to folder must not contain a leading or trailing "/" e.g. folderA/folderB/fileName.txt
     * @returns IDriveItems
     */
    getItemByPath(path) {
        return DriveItem(this, combine("root:/", `${path}:`));
    }
};
_Drive = __decorate([
    defaultPath("drive")
], _Drive);
export { _Drive };
export const Drive = graphInvokableFactory(_Drive);
/**
 * Describes a collection of Drive objects
 *
 */
let _Drives = class _Drives extends _GraphQueryableCollection {
};
_Drives = __decorate([
    defaultPath("drives"),
    getById(Drive)
], _Drives);
export { _Drives };
export const Drives = graphInvokableFactory(_Drives);
/**
 * Describes a Root instance
 *
 */
let _Root = class _Root extends _GraphQueryableInstance {
    /**
     * Method for retrieving children of a folder drive item.
     * @returns IDriveItems
     */
    get children() {
        return DriveItems(this, "children");
    }
    /**
     * Search drive for items matching the query
     * @param query string, search parameter
     * @returns IGraphQueryableCollection
     */
    search(query) {
        return GraphQueryableCollection(this, `search(q='${query}')`);
    }
    /**
     * Method for retrieving thumbnails of the drive items.
     * @returns IGraphQueryableCollection
     */
    get thumbnails() {
        return GraphQueryableCollection(this, "thumbnails");
    }
    /**
     * Get changes since optional change token
     * @param token - string (Optional)
     * change token
     * @returns IDeltaItems
     */
    delta(token) {
        const path = `delta${(token) ? `(token=${token})` : ""}`;
        const query = GraphQueryableCollection(this, path);
        query.on.parse.replace(errorCheck);
        query.on.parse(async (url, response, result) => {
            const json = await response.json();
            const nextLink = json["@odata.nextLink"];
            const deltaLink = json["@odata.deltaLink"];
            result = {
                next: () => (nextLink ? AsPaged(GraphQueryableCollection([this, nextLink]))() : null),
                delta: () => (deltaLink ? GraphQueryableCollection([query, deltaLink])() : null),
                values: json.value,
            };
            return [url, response, result];
        });
        return query;
    }
    /**
     * Method for uploading a new file, or updating the contents of an existing file.
     * @param fileOptions - IFileOptions
     * @param content - any
     * @param filePathName - string (Optional)
     * e.g. myfile.txt or myfolder/myfile.txt, unneeded for updates
     * @param contentType - string (Optional)
     * e.g. "application/json; charset=utf-8" for JSON files
     * @returns IDriveItem
     */
    async upload(fileOptions) {
        return Reflect.apply(driveItemUpload, this, [fileOptions]);
    }
    /**
     * Method for getting item analytics. Defaults to lastSevenDays.
     * @param analyticsOptions - IAnalyticsOptions (Optional)
     * @returns IGraphQueryableCollection<IItemAnalytics>
     */
    analytics(analyticsOptions) {
        const query = `analytics/${analyticsOptions ? analyticsOptions.timeRange : "lastSevenDays"}`;
        return GraphQueryableCollection(this, query);
    }
};
_Root = __decorate([
    defaultPath("root")
], _Root);
export { _Root };
export const Root = graphInvokableFactory(_Root);
/**
 * Describes a Drive Item instance
 *
 */
let _DriveItem = class _DriveItem extends _GraphQueryableInstance {
    /**
     * Method for retrieving children of a folder drive item.
     * @returns IDriveItems
     */
    get children() {
        return DriveItems(this, "children");
    }
    /**
     * Method for retrieving thumbnails of the drive items.
     * @returns IGraphQueryableCollection
     */
    get thumbnails() {
        return GraphQueryableCollection(this, "thumbnails");
    }
    /**
     * Method for retrieving the versions of a drive item.
     * @returns IDriveItemVersionInfo
     */
    get versions() {
        return GraphQueryableCollection(this, "versions");
    }
    /**
     * Method for moving a drive item
     * @param parentReference - { id: string} - reference to destination folder drive item
     * @param name - string - name of the file in the destination
     * @deprecated (v3.11.0) use `moveItem`
     */
    move(parentReference, name) {
        return graphPatch(this, body({ name, ...parentReference }));
    }
    /**
     * Method for moving a file to a new location and/or name.
     * @param moveOptions - IItemOptions object
     * @returns string - the URL where the new file is located
     */
    async moveItem(moveOptions) {
        return graphPatch(this, body(moveOptions));
    }
    /**
     * Method for retrieving the contents of a drive item.
     * @returns Blob
     */
    async getContent() {
        const info = await this();
        const query = GraphQueryable([this, info["@microsoft.graph.downloadUrl"]], null)
            .using(BlobParse())
            .using(CacheNever());
        query.on.pre(async (url, init, result) => {
            init.responseType = "arraybuffer";
            return [url, init, result];
        });
        return query();
    }
    /**
     * Method for setting the contents of a IDriveItem
     * @param content - any - content to upload to the drive item
     * @returns - { id: string; name: string; size: number }
     * @deprecated (v3.11.0) use `upload`
     */
    setContent(content) {
        return graphPut(DriveItem(this, "content"), {
            body: content,
        });
    }
    /**
     * Method for copying a file to a new location and/or name.
     * @param copyOptions - IItemOptions
     * @returns string, the URL where the new file is located
     */
    async copyItem(copyOptions) {
        const creator = DriveItem(this, "copy").using((instance) => {
            instance.on.parse(async (url, response, result) => {
                result = response.headers.has("location") ? response.headers : response;
                return [url, response, result];
            });
            return instance;
        });
        const data = await graphPost(creator, body(copyOptions));
        let result = null;
        if (data.has("location")) {
            result = data.get("location");
        }
        return result;
    }
    /**
     * Method for converting the format of a drive item.
     * @param format - string - "pdf" is only option
     * @returns Blob - content of the converted file
     */
    async convertContent(format) {
        const query = GraphQueryable(this, `content?format=${format}`)
            .using(BlobParse())
            .using(CacheNever());
        query.on.pre(async (url, init, result) => {
            init.responseType = "arraybuffer";
            return [url, init, result];
        });
        return query();
    }
    /**
     * Method for uploading a new file, or updating the contents of an existing file.
     * @param fileOptions - IFileOptions object
     * @param content - any
     * @param filePathName - string (Optional)
     * e.g. myfile.txt or myfolder/myfile.txt, unneeded for updates
     * @param contentType - string (Optional)
     * e.g. "application/json; charset=utf-8" for JSON files
     * @returns IDriveItem
     */
    async upload(fileOptions) {
        return Reflect.apply(driveItemUpload, this, [fileOptions]);
    }
    // TODO: Upload Session for large files
    // public uploadSession(fileOptions: IFileOptions): Promise<void> {
    // }
    /**
     * Method for getting a temporary preview image of a drive item.
     * @param previewOptions - IPreviewOptions (Optional)
     * @returns IDriveItemPreviewInfo
     */
    async preview(previewOptions) {
        return graphPost(DriveItem(this, "preview"), body(previewOptions));
    }
    /**
     * Method for getting item analytics. Defaults to lastSevenDays.
     * @param analyticsOptions - IAnalyticsOptions (Optional)
     * @returns IGraphQueryableCollection<IItemAnalytics>
     */
    analytics(analyticsOptions) {
        const query = `analytics/${analyticsOptions ? analyticsOptions.timeRange : "lastSevenDays"}`;
        return GraphQueryableCollection(this, query);
    }
};
_DriveItem = __decorate([
    deleteable(),
    updateable()
], _DriveItem);
export { _DriveItem };
export const DriveItem = graphInvokableFactory(_DriveItem);
/**
 * Describes a collection of Drive Item objects
 *
 */
let _DriveItems = class _DriveItems extends _GraphQueryableCollection {
    /**
     * Adds a file to this collection of drive items.
     * For more upload options please see the .upload method on DriveItem and Root.
     * @param filename - string - name of new file
     * @param content - string - contents of file
     * @param contentType - string - content type for header - default to "application/json"
     * @returns IDriveItemAddResult - result with file data and chainable drive item object
     */
    async add(filename, content, contentType = "application/json") {
        const postBody = {
            name: filename,
            file: {},
            "@microsoft.graph.conflictBehavior": "rename",
        };
        const driveItem = await graphPost(this, body(postBody));
        const q = DriveItem([this, `${combine("drives", driveItem.parentReference.driveId, "items", driveItem.id)}`], "content");
        q.using(InjectHeaders({
            "Content-Type": contentType,
        }));
        const data = await graphPut(q, { body: content });
        return {
            data,
            driveItem: DriveItem([this, `${combine("drives", driveItem.parentReference.driveId, "items", driveItem.id)}`]),
        };
    }
    /**
     * Adds a folder to this collection of drive items.
     * @param name - string, name of new folder
     * @param driveItem - DriveItem (Optional) - override default drive item properties
     * @returns IDriveItemAddResult - result with folder data and chainable drive item object
     */
    async addFolder(name, driveItem) {
        let postBody = {
            name,
            folder: {},
            "@microsoft.graph.conflictBehavior": "rename",
        };
        if (driveItem) {
            if (driveItem.name == null) {
                driveItem.name = name;
            }
            if (driveItem["@microsoft.graph.conflictBehavior"] == null) {
                driveItem["@microsoft.graph.conflictBehavior"] = "rename";
            }
            postBody = driveItem;
        }
        const data = await graphPost(this, body(postBody));
        return {
            data,
            driveItem: DriveItem([this, `${combine("drives", data.parentReference.driveId, "items", data.id)}`]),
        };
    }
};
_DriveItems = __decorate([
    getById(DriveItem)
], _DriveItems);
export { _DriveItems };
export const DriveItems = graphInvokableFactory(_DriveItems);
//# sourceMappingURL=types.js.map